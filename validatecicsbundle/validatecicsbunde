#!/bin/bash
#############################################################################################
# Script to validate contents of a CICS bundle against a set of rules
#
# Licensed Materials - Property of IBM.
# (c) Copyright IBM Corporation 2016. All Rights Reserved.
# US Government Users Restricted Rights
# Use, duplication or disclosure restricted by GSA ADP Schedule Contract with IBM Corporation
#############################################################################################

show_usage () {
	echo -e "Usage:\t"$(basename "$0") "[-hv] -r FILE DIRECTORY"
}

show_help () {
 	show_usage
  	echo
  	echo "Validate the CICS bundle specified by DIRECTORY against a set of rules specified by FILE."
  	echo "The script return code is set to 0 if all rules validate, otherwise it is set to > 0"
  	echo
  	echo "Options:"
  	echo -e "\t-h, --help\t\tHelp"
  	echo -e "\t-r, --rules FILE\tRules file"
  	echo -e "\t-v, --verbose\t\tVerbose output"
	echo
  	echo "Example:"
  	echo -e "\t"$(basename "$0") "-r ~/rules/production.txt ~/built/bundles/MyBundle"
  	echo
  	echo -e "DIRECTORY is the CICS bundle directory to be validated."
  	echo -e "FILE is a text file containing rules, one on each line, in the following format:"
  	echo -e "\tfile xpath regex"
  	echo
  	echo -e "\twhere:"
  	echo
  	echo -e "\tfile is the file patthern, such as *.urimap or cics.xml"
  	echo -e "\txpath is the xpath expression to evaluate"
  	echo -e "\tregex is the regular express the xpath expression must match"
  	echo
  	echo -e "\tComments starting with #, blank lines, and tab characters are ignored"
  	echo
  	echo "Example ~/rules/production.txt:"
	echo -e "\t# The resource name for all URIMAPs must start with EX" 
	echo -e "\t*.urimap string(//@name) ^EX"
	echo
	echo -e "\t# All URIMAP scheme attribute must be HTTP"
	echo -e "\t*.urimap string(//@scheme) HTTP"
	echo
	echo -e "\t# All URIMAP authenticate attribute must be NO"
	echo -e "\t*.urimap string(//@authenticate) NO"
	echo
	echo -e "\t# All WEBSERVICE pipeline attribute must be PIPE01"
	echo -e "\t*.webservice string(//@pipeline) PIPE01"
	echo
	echo -e "\t# All WEBSERVICE wsdlfile attribute must be present"
	echo -e "\t*.webservice boolean(//*[@validation]) true"
	echo
	echo -e "\t# JVMSERVER resource must not be present"
	echo -e "\tcics.xml boolean(//*[local-name()='define'][@type=\"http://www.ibm.com/xmlns/prod/cics/bundle/JVMSERVER\"]) false"
}

# Function to validate the XPATH value against a regular expression
validate_xpath () {
	local XPATH=$1
	local REGEX=$2
	local FILE=$3
	local RULE=$4
	local VALUE=$(xmllint --xpath "${XPATH}" "${FILE}")
	local RC=$?

	if [[ ${RC} != 0 ]] ; then
		echo "xmllint gave return code ${RC}"
		exit 1
	fi

	if [[ -z ${VALUE} ]]; then
		RC=1
	else
		# Compare result of XPATH with expected regex
		echo ${VALUE} | $(sed -n '/'${REGEX}'/!{q2}')
		RC=$?
	fi

	if [[ ${RC} == 1 ]] ; then
		echo "Rule ${RULE}: File:${FILE} XPath:${XPATH} failed"
	elif [[ ${RC} == 2 ]] ; then
		echo "Rule ${RULE}: File:${FILE} XPath:${XPATH}=${VALUE} did not match regex ${REGEX}"
	elif [[ $VERBOSE == 1 ]] ; then
		echo "Rule ${RULE}: File:${FILE} XPath:${XPATH}'=${VALUE} matched regex ${REGEX}"
	fi
	
	exit ${RC}
}

# Function to validate a specified resource file
validate_rules_for_file () {
	local TOTALRC=0
	local RC=0
	local FILE=${1}
	local FILEBASENAME=$(basename "$FILE")

	for (( i = 0 ; (i * 3) < ${#VALIDATIONS[@]} ; i += 1 )) ; do
		case "$FILEBASENAME" in (${VALIDATIONS[${i}*3]}) 
			MESSAGE=$(validate_xpath "${VALIDATIONS[${i}*3+1]}" "${VALIDATIONS[${i}*3+2]}" "${FILE}" "$i")
			RC=$?

			if [[ ! -z ${MESSAGE} ]] ; then 
				echo -n ${MESSAGE}"\n"
			fi
			
			TOTALRC=$((TOTALRC + RC)) ;;
		esac
	done

	exit ${TOTALRC}
}

# Process script long options by transforming them to the short option equivalent
for arg in "$@"; do
  	shift
  	case "$arg" in
    	"--help")
    		set -- "$@" "-h" ;;
    	"--verbose")
    		set -- "$@" "-v" ;;
		"--rules")
			set -- "$@" "-r" ;;
    	*)
    	    set -- "$@" "$arg"
	esac
done

# Process script short options
VERBOSE=0
while getopts ":hvr:" opt; do
	case "$opt" in
		r)
			RULES=${OPTARG} ;;
		v)
			VERBOSE=1 ;;
		h)
			show_help
			exit 0 ;;
	esac
done
shift $((OPTIND-1))

# The remainder of the command line
DIRECTORY=$@

# Validate directory is a CICS bundle
if [[ -z "${DIRECTORY}" ]] ; then
	echo "Directory was not specified"
	show_usage
	exit 1
elif [[ ! -d "${DIRECTORY}" ]] ; then
	echo "${DIRECTORY} is not a directory"
	show_usage
	exit 1
elif [[ ! -f "${DIRECTORY}/META-INF/cics.xml" ]] ; then
	echo "${DIRECTORY} directory is not a CICS bundle"
	show_usage
	exit 1
fi

# Validate rules file
if [[ ! -f ${RULES} ]] ; then
	echo "${RULES} is not a file, or does not exist"
	show_usage
	exit 1
fi

# Load the rules file, strip blank lines, and strip character "#" and trailing characters
RULES_CONTENTS=$(sed -e 's/[[:space:]]*#.*// ; /^[[:space:]]*$/d ; s/\t/ /g' "${RULES}")

# For each rule, extract 1st word as file pattern, 2nd word as xpath to validate, and trailing characters as regex
if [[ $VERBOSE == 1 ]] ; then
	echo "Loading rules:"
fi
INDEX=0
while read -r FILEPATTERN XPATH REGEX ; do
	if [[ -z "${FILEPATTERN}" ]] ; then
		echo "Rule ${INDEX}: File pattern not specified"
		exit 1
	fi
	if [[ -z "${XPATH}" ]] ; then
		echo "Rule ${INDEX}: XPath not specified"
		exit 1
	fi
		if [[ -z "${REGEX}" ]] ; then
		echo "Rule ${INDEX}: Regular expression not specified"
		exit 1
	fi
	
	VALIDATIONS[(${INDEX}*3)]="$FILEPATTERN"
	VALIDATIONS[(${INDEX}*3)+1]="$XPATH"
	VALIDATIONS[(${INDEX}*3)+2]="$REGEX"

	if [[ $VERBOSE == 1 ]] ; then
		echo "Rule ${INDEX}: File pattern:${FILEPATTERN} XPath:${XPATH} regex:${REGEX}"
	fi

	INDEX=$((INDEX + 1))
done <<< "$RULES_CONTENTS"

# For each file in the bundle that is not hidden validate it against the rules
if [[ $VERBOSE == 1 ]] ; then
	echo
	echo "Validating rules:"
fi

TOTALRC=0
cd ${DIRECTORY}
for FILE in $(find . -type f -not -path '*/\.*' -name "*") ; do
	MESSAGE=$(validate_rules_for_file "${FILE}")
	RC=$?
  
	if [[ ! -z ${MESSAGE} ]] ; then 
		echo -n -e ${MESSAGE}
	fi

	TOTALRC=$((TOTALRC + RC))
done

if [[ $VERBOSE == 1 ]] ; then
	echo "Exiting with RC=${TOTALRC}"
fi
exit ${TOTALRC}
